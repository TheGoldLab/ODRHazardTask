function [fits_, lambda_, thresh_] = quick_plotBinTime(di, tbinsize, tbinlen, tbinshow, ax1, ax2)% function [fits_, lambda_, thresh_] = quick_plotBinTime(di, tbinsize, tbinlen, tbinshow, ax1, ax2)%% di is [coh(1...10) time(ms) correct(0/1)] x trials%if nargin < 1 | isempty(di)  return;endif nargin < 2 | isempty(tbinsize)  tbinsize = 13.333; % msendif nargin < 3 | isempty(tbinlen)  tbinlen = 5;endif nargin < 4 | isempty(tbinshow)  tbinshow = [100 200 300];endif nargin < 5  ax1 = [];endif nargin < 6  ax2 = [];end% First estimate a lapse rate, using only long-duration trialscbins = unique(di(:,1));dat   = nans(length(cbins), 3);Lt    = di(:, 2) > 300;for i = 1:length(cbins)  La = Lt & di(:,1) == cbins(i);  dat(i,:) = [cbins(i) sum(di(La,3))/length(di(La,3)) length(di(La,3))];end[fits,llik,pred,sems]=quick_fit(dat);lambda = fits(1);% now cycle through time binstbins     = 90:tbinsize:max(di(:,2))-tbinlen*tbinsize;num_tbins = length(tbins);% store fits, rows are tbins, % cols are tbin, alpha_mean, alpha_sem, beta_mean, beta_semfits   = zeros(num_tbins, 5);% some useful stuffco       = {'k' 'c' 'r' 'g' 'b'};ci       = 1;tbinshow = nearest(tbinshow, tbins);dat      = zeros(length(cbins),3);for t = 1:num_tbins  Lt = di(:,2) >= tbins(t) & di(:,2) < (tbins(t) + tbinlen*tbinsize);  if(sum(Lt)>30)	 for c = 1:length(cbins)		Ls = Lt & di(:,1) == cbins(c);		dat(c,:) = [cbins(c) sum(di(Ls,3))/length(di(Ls,3)) length(di(Ls,3))];	 end	 % do & save the fit	 [fit,llik,pred,sem]  = quick_fit(dat, lambda);	 fits(t, :) = [tbins(t) fit(2) sem(2) fit(3) sem(3)];	 	 % maybe show it	 if ~isempty(ax1) & ismember(tbins(t),tbinshow)		quick_plot(dat, lambda, fits(t,2), fits(t,4), ax1, co{ci});		hold on;		drawnow;		ci = ci + 1;	 end  endendif ~isempty(ax2)  axes(ax2);  plot(fits(:,1),fits(:,2));endif nargout > 0  fits_ = fits;endif nargout > 1  lambda_ = lambda;endif nargout > 2  thresh_ = quick_val(1,lambda,1,1);end