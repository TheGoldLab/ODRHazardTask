function [fits_,llik_,pred_,sems_]=quickT_fit(data, error_flag)%% QUICKT_FIT fits a weibull function to psychometric data using%   maximum likelihood maximization under binomial assumptions. It uses%   quickT_err for error calculation.%%  Usage: [fits,llik,pred,sems]=quick_fit(data)% 	Input values are:%     data, in 3 columns...%		         data(1) = x%		         data(2) = fraction correct (0..1)%		         data(3) = number of observations%	   lambda, Specifies lapse rate. Must be on the interval of [0,1]; if%              not (or not given), it's a free parameter.%      error_flag flag that specifies monte carlo should be used to calculate%              sems%% 	Return values are:%		fits, [alpha; beta; lambda]%              alpha is threshold%              beta is the slope/shape term%              lambda is the lapse rate%		llik,  The log likelihood of obtaining the data give the fit%       pred,  A vector of the probability of making a correct choice given%              the fit%       sems,  Standard errors of the fits. Approximated using the%              numerical HESSIAN returned by fmincon (default)%              or monte carlo method (if error_type is given)% 	4/1/95 to use optimization toolbox, contsrained fit -- nope%  		old code is quickfit_no_opt.m% 	12/11/96  jdr & mns fixed guessing bug (we hope) %	7/13/01 jig updated, cleaned up and changed fmins to fminconglobal Data;if nargin < 1 || isempty(data)    return;endData = data;% use linear interpolation to guess alpha% next line takes x and %-cor columns, flips them and interpolates along% x to find the value corresponding to .8 correct.  The interpolation% requires monotonic %-cor column, so we sort the matrix 1st.% % Remember, it's just a guess.% gpct    = 0.82;% row_lo = max(find(Data(:,2)<=gpct));% if isempty(row_lo)              % no percent correct > gpct%     a_guess = min(Data(1,2));% elseif row_lo == size(Data,1)   % no percent correct < gpct%     a_guess = max(Data(end,2));% else                            % interpolate%     row_hi = row_lo + 1;%     a_guess = Data(row_lo,1) + (Data(row_hi,1) - Data(row_lo,1)) * ...%         (gpct - Data(row_lo,2)) / (Data(row_hi,2) - Data(row_lo,2));% end%% do the fit[fits,f,e,o,l,g,H] = fmincon('quickT_err', ...    [ 0.05  0.01 0.15 0.15  .6  1.2  1.2    0]', [1 1 0 0 0 0 0 0], 1, [], [], ...    [-0.4   0    0.01 0.01 -8   0.01 0.01 -6]', ...    [ 0.4   .9   40   40    8   40   40    6]', [], ...    optimset('LargeScale', 'off', 'Display', 'off', 'Diagnostics', 'off'));% return the fitsif nargout > 0    fits_ = fits';end% return log likelihoodif nargout > 1    llik_ = -quickT_err(fits);end% return the predicted probability (of a correct response) for each observationif nargout > 2    pred_ = quickT_val(Data(:,1:end-1), fits);end% standard errors% The covariance matrix is the negative of the inverse of the % hessian of the natural logarithm of the probability of observing % the data set given the optimal parameters.% For now, use the numerically-estimated HESSIAN returned by fmincon% (which remember is computed from -log likelihood)if nargout > 3        % error_type is flag .. if not given (default), use Hessian    if nargin < 2 || isempty(error_flag)        % -H because we used -logL in quick_err        sems_ = sqrt(diag(-((-H)^(-1))));            else % DOES NOT WORK        % try getting monte-carlo simulated errors        num_sets = 50;        mcfits   = zeros(num_sets, length(fits_));        dat      = Data;        for i = 1:num_sets            Data(:,2)   = binornd(dat(:,3),dat(:,2))./dat(:,3);            mcfits(i,:) = quick_fit(Data,lambda)';        end                %   means = mean(mcfits)        sems_  = [fits_ - prctile(mcfits,16)' prctile(mcfits,84)' - fits_];    endend