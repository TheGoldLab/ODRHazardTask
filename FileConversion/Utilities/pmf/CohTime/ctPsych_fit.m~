function [fits_,sems_,stats_,preds_,resids_] = ...    ctPsych_fit(fun,data,pcor,init,varargin)%function [fits_,sems_,stats_,preds_,resids_] = ...%    ctPsych_fit(fun,data,pcor,init,varargin)%% CTPSYCH_FIT fits a given model ("fun") to psychometric data --%   as a function of BOTH motion coherence (c) and viewing time (t) -- %   using maximum likelihood maximization. 'fun' is the name or index of%   a supplied function for computing the underlying decision variable%% 	Input values are:%     fun  ... function handle. see ddFun%     data, rows are trials, columns are 'fun'-specific, but typically:%		   data(1) = coh  (0 ... 1)%          data(2) = time (fractional seconds)%          data(3) = dot dir: left (-1) / right (1)%     pcor ... rows are trials, columns are:%          pcor(1) = pct or correct (1) / error (0)%          pcor(2) = (optinal) n%     init ... optional array of initial values. Otherwise given%           by 'fun'%     varargin ... extra args to send to ctPsych_fit%% 	Return values are:%     fits_   ... fun-specific%     sems_   ... Standard errors of the fits. Approximated using the%                   numerical HESSIAN returned by fmincon (default)%     stats_  ... [fitLLR Deviance Average_deviance p]%                   fitLLR is the log likelihood of obtaining the %                       data given the fit (returned by quick_err)%                   Deviance is 2(dataLLR - fitLLR) = -2*fitLLR%                   Average_deviance is Deviance./n. duh.%                   p is probability from chi^2 pdf with df = #blocks-3%     preds_  ... A vector of the probability of making a correct choice given%                   the fit%     resids_ ... col 1: outcome deviance residuals (see below)%                     2: outcome direct residuals%                     3: choice deviance residuals%                     4: choice direct residuals% Created by jig 9/29/05if nargin < 1 || isempty(data)    returnendif nargin < 2 || isempty(fun)    fun = @ddExp4b;elseif ischar(fun)    fun = str2func(fun);end% get initial values, bounds from fun%  send in data appended with pcorinits = feval(fun, [], [data pcor], varargin{:});% possibly replace initial values with argumentif nargin >= 4    if length(init) == size(inits,1)    inits(:,1) = init(:);end% and... fitit.[fits_,f,e,o,l,g,H] = fmincon('ctPsych_err', ...    inits(:, 1), [], [], [], [], inits(:, 2), inits(:, 3), [], ...    optimset('LargeScale', 'off', 'Display', 'off', 'Diagnostics', 'off'), ...    fun, data, pcor, varargin{:});if nargout > 1    % Standard errors    %   The covariance matrix is the negative of the inverse of the    %   hessian of the natural logarithm of the probability of observing    %   the data set given the optimal parameters.    %   For now, use the numerically-estimated HESSIAN returned by fmincon    %   (which remember is computed from -log likelihood)    % -H because we used -logL in quick_err    sems_ = sqrt(diag(-((-H)^(-1))));end% return statsif nargout > 2        % log likelihood of the fits ("M1" in Watson)    % is just the negative of the error function    M1 = -ctPsych_err(fits_, fun, data, pcor, varargin{:});        % deviance is 2(M0 - M1), where    % M0 is the log likelihood of the data ("saturated model") --    %   which in this case is, of course, ZERO    dev = -2*M1;        % average deviance    adev = dev./size(data, 1);        % probability is from cdf    p = 1 - chi2cdf(dev, size(data, 1) - size(fits_, 1));        stats_ = [M1 dev adev p];end% return the predicted probability (of a correct response) for each observation% again using only first fitif nargout > 3        preds_ = feval(fun, fits_, data, varargin{:});end% return the deviance residuals ... these are the square roots%   of each deviance computed individually, signed according to%   the direction of the arithmatic residual y_i - p_i.% See Wichmann & Hill, 2001, "The psychometric function: I. Fitting,%   sampling, and goodness of fit", eqs. 11 and 12.if nargout > 4    % useful selection arrays    Lcor = pcor(:,1) == 1;    Lerr = pcor(:,1) == 0;        Llt  = data(:,3) == -1;    Lrt  = data(:,3) == 1;        % avoid p=0,1    TINY = 0.0001;    pds  = preds_;    pds(pds==0) = TINY;    pds(pds==1) = 1 - TINY;        % first column is residual deviance for outcome    %  correct trials =  sqrt(-2 * log(p))    %  error trials   = -sqrt(-2 * log(1-p))        rdo       = pds;    rdo(Lerr) = 1 - rdo(Lerr);    rdo       = (pcor(:,1)*2-1).*sqrt(-2*log(rdo));        % second column is direct residual for outcome    %  correct trials = 1 - p;    %  error trials   = -p;    rro       = pds;    rro(Lcor) = 1 - rro(Lcor);    rro(Lerr) = -rro(Lerr);        % third column is residual deviance for choice;    %   here we 'flip' p for leftward dots    %   xY is x dir, Y choice    %   rR = sqrt(-2*log(p))    %   rL = -sqrt(-2*log(1-p))    %   lR = sqrt(-2*log(1-p))    %   lL = -sqrt(-2*log(p))    rdc           = sqrt(-2*log(pds));    rdcMP         = sqrt(-2*log(1-pds));    rdc(Lerr&Lrt) = -rdcMP(Lerr&Lrt);    rdc(Lcor&Llt) = -rdc(Lcor&Llt);    rdc(Lerr&Llt) = rdcMP(Lerr&Llt);    % fourth column is direct residual for choice    %   rR = 1 - p    %   rL = -p    %   lR = p    %   lL = -(1 - p)    rrc = pds;    rrc(Lcor&Lrt) = 1 - rrc(Lcor&Lrt);    rrc(Lerr&Lrt) = -rrc(Lerr&Lrt);    rrc(Lcor&Llt) = rrc(Lcor&Llt) - 1;        resids_ = [rdo rro rdc rrc];end