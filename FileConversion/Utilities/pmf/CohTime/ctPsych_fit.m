function [fits_,cis_,stats_,preds_,resids_] = ...    ctPsych_fit(fun,data,pcor,th_args,ci_args,init,varargin)%function [fits_,cis_,stats_,preds_,resids_] = ...%    ctPsych_fit(fun,data,pcor,init,citype,varargin)%% CTPSYCH_FIT fits a given model ("fun") to psychometric data --%   as a function of BOTH motion coherence (c) and viewing time (t) --%   using maximum likelihood maximization. 'fun' is the name or index of%   a supplied function for computing the underlying decision variable%% 	Input values are:%     fun  ... function handle. see ddFun%     data, rows are trials, columns are 'fun'-specific, but typically:%		   data(1) = coh  (0 ... 1)%          data(2) = time (fractional seconds)%          data(3) = <OPTIONAL> dot dir: left (-1) / right (1) / 0%          data(4) = <OPTIONAL> choice: left (-1) / right (1)%     pcor ... rows are trials, columns are:%          pcor(1) = pct or correct (1) / error (0)%          pcor(2) = (optinal) n%     th_args ... parameters used to compute threshold: {frac_correct view_time}%     ci_args ... cell array indicating how to compute confidence intervals%                   on the fit parameters:%                   {<n> <ci> <thresh>}%     init ... optional array of initial values. Otherwise given%                   by 'fun'%     varargin ... extra args to send to ctPsych_fit%% 	Return values are:%     fits_   ... fun-specific%     cis_    ... Confidence intervals of the fits. Approximated using the%                   numerical HESSIAN returned by fmincon (default)%     stats_  ... [fitLLR Deviance Average_deviance p]%                   fitLLR is the log likelihood of obtaining the%                       data given the fit (returned by quick_err)%                   Deviance is 2(dataLLR - fitLLR) = -2*fitLLR%                   Average_deviance is Deviance./n. duh.%                   p is probability from chi^2 pdf with df = #blocks-3%     preds_  ... A vector of the probability of making a correct choice given%                   the fit%     resids_ ... col 1: outcome deviance residuals (see below)%                     2: outcome direct residuals%                     3: choice deviance residuals%                     4: choice direct residuals% Copyright 2005 by Joshua I. Gold%   University of Pennsylvania%% Created by jig 9/29/05if nargin < 1 || isempty(data)    returnendif nargin < 2 || isempty(fun)    fun = @ddExp3;elseif ischar(fun)    fun = str2func(fun);end% Check data column ... if data is only two%   columns (coh and time), remove 0% coh trials%   from fitting, since % correct at 0% coh is%   meaningless. Be careful to replace later %   (in preds_ and resids_)...% However, if third (dot dir) and fourth (choice)%   columns are given in data, recode 0% coh trials%   as all RT dirs and correct/error based on choicedcol = size(data,2) >= 2 && all(ismember(data(:,end), -1:1));L0   = data(:,1) == 0;if any(L0)    if dcol        Lrt = data(:,4) == 1;        pcor(L0& Lrt, 1) = 1;        pcor(L0&~Lrt, 1) = 0;        data(L0, 3)      = 1;        data             = data(:,1:3);        L0               = false;    else        data             = data(~L0, :);    endend% get initial values, bounds from fun%  send in data appended with pcorinits = feval(fun, [], [data pcor], varargin{:});% possibly replace initial values with argumentif nargin > 5    if length(init) == size(inits,1)        inits(:,1) = init(:);    elseif length(init) < size(inits,1)        inits(1:length(init)) = init(:);    endend% and... fitit.[fits,f,e,o,l,g,H] = fmincon('ctPsych_err', ...    inits(:, 1), [], [], [], [], inits(:, 2), inits(:, 3), [], ...    optimset('LargeScale', 'off', 'Display', 'off', 'Diagnostics', 'off'), ...    fun, data, pcor, varargin{:});% get predictions, which we might use for semspreds = feval(fun, fits, data, varargin{:});% compute thresholdfits_ = fits;if nargin > 3 && iscell(th_args)    if isempty(th_args)        pctc   = 0.8161; % from Weibull        vtime  = 1.0;    % seconds    elseif length(th_args) == 1        pctc   = th_args{1};        vtime  = 1.0;    else        pctc   = th_args{1};        vtime  = th_args{2};    end    fits_(end+1) = ctPsych_thresh(fun, fits, pctc, vtime);endif nargout > 1    % confidence intervals    if nargin < 5 || ~iscell(ci_args)        % Compute Standard errors        %   The covariance matrix is the negative of the inverse of the        %   hessian of the natural logarithm of the probability of observing        %   the data set given the optimal parameters.        %   For now, use the numerically-estimated HESSIAN returned by fmincon        %   (which remember is computed from -log likelihood)        % -H because we used -logL in quick_err        cis_ = sqrt(diag(-((-H)^(-1))));    else        % citype is cell array with:        %   number of simulated data sets to create        %   confidence interval        if isempty(ci_args)            ci_args = {[], []};        end        % Check for input etype, which indicates that we will use        %    Monte Carlo resampling (parametric bootstrap).        %   See Wichmann & Hill (2001)        %       The psychometric function: II. Bootstrap-        %           based confidence intervals and sampling        % citype{1} is number of simulated data sets to use        if isempty(ci_args{1})            mcn = 100;        else            mcn = ci_args{1};        end        if mcn > 0            if size(pcor,2) == 1                ns = ones(size(pcor,1),1);            else                ns = pcor(:,2);            end            mcfits = zeros(mcn, length(fits_));            for ii = 1:mcn                if ~mod(ii,10)                    disp(sprintf('Bootstrap CIs, set %d', ii))                end                % compute fit on simulated data set                mcfit = fmincon('ctPsych_err', ...                    fits, [], [], [], [], inits(:,2), inits(:,3), [], ...                    optimset('LargeScale', 'off', 'Display', 'off', 'Diagnostics', 'off'), ...                    fun, data, [binornd(ns,preds)./ns ns], varargin{:});                                % possibly compute threshold                if length(fits_) > length(fits)                    mcfit = [mcfit; ctPsych_thresh(fun, mcfit, pctc, vtime)];                end                mcfits(ii,:) = mcfit;            end            % ci_args{2} is confidence interval            %   'sem' is 68            %   'iqr' is 50            %   90 is default            if length(ci_args) < 2 || isempty(ci_args{2})                CI = 90; % confidence interval            elseif ischar(ci_args{2})                switch ci_args{2}                    case 'sem'                        CI = 68;                    case 'iqr'                        CI = 50;                    otherwise                        CI = 90;                end            elseif isscalar(ci_args{2})                CI = ci_args{2};            end            cis_ = [prctile(mcfits,50-CI/2)' prctile(mcfits,50+CI/2)'];        else            cis_ = [];        end    endend% return statsif nargout > 2    % log likelihood of the fits ("M1" in Watson)    % is just the negative of the error function    M1 = -ctPsych_err(fits, fun, data, pcor, varargin{:});    % deviance is 2(M0 - M1), where    % M0 is the log likelihood of the data ("saturated model") --    %   which in this case is, of course, ZERO    dev = -2*M1;    % average deviance    adev = dev./size(data, 1);    % probability is from cdf    p = 1 - chi2cdf(dev, size(data, 1) - size(fits, 1));    stats_ = [M1 dev adev p];end% return the predicted probability (of a correct response) for %   each observation again using only first fitif nargout > 3    % check if we stripped 0% coh trials    if any(L0)        preds_      = 0.5*ones(size(L0));        preds_(~L0) = preds;    end    preds_ = preds;end% return the deviance residuals ... these are the square roots%   of each deviance computed individually, signed according to%   the direction of the arithmatic residual y_i - p_i.% See Wichmann & Hill, 2001, "The psychometric function: I. Fitting,%   sampling, and goodness of fit", eqs. 11 and 12.if nargout > 4    % useful selection arrays    Lcor = pcor(:,1) == 1;    Lerr = pcor(:,1) == 0;    % avoid p=0,1    TINY = 0.0001;    pds  = preds_;    pds(pds==0) = TINY;    pds(pds==1) = 1 - TINY;    % first column is residual deviance for outcome    %  correct trials =  sqrt(-2 * log(p))    %  error trials   = -sqrt(-2 * log(1-p))    rdo       = pds;    rdo(Lerr) = 1 - rdo(Lerr);    rdo       = (pcor(:,1)*2-1).*sqrt(-2*log(rdo));    % second column is direct residual for outcome    %  correct trials = 1 - p;    %  error trials   = -p;    rro       = pds;    rro(Lcor) = 1 - rro(Lcor);    rro(Lerr) = -rro(Lerr);    % Third and fourth columns are based on CHOICE --    %   only compute if third column of data is given,    %   listing dot directions per trial    if dcol                Llt  = data(:,end) == -1;        Lrt  = data(:,end) == 1;        % third column is residual deviance for choice;        %   here we 'flip' p for leftward dots        %   xY is x dir, Y choice        %   rR = sqrt(-2*log(p))        %   rL = -sqrt(-2*log(1-p))        %   lR = sqrt(-2*log(1-p))        %   lL = -sqrt(-2*log(p))        rdc           = sqrt(-2*log(pds));        rdcMP         = sqrt(-2*log(1-pds));        rdc(Lerr&Lrt) = -rdcMP(Lerr&Lrt);        rdc(Lcor&Llt) = -rdc(Lcor&Llt);        rdc(Lerr&Llt) = rdcMP(Lerr&Llt);        % fourth column is direct residual for choice        %   rR = 1 - p        %   rL = -p        %   lR = p        %   lL = -(1 - p)        rrc = pds;        rrc(Lcor&Lrt) = 1 - rrc(Lcor&Lrt);        rrc(Lerr&Lrt) = -rrc(Lerr&Lrt);        rrc(Lcor&Llt) = rrc(Lcor&Llt) - 1;        resids_ = [rdo rro rdc rrc];    else        % not computed by choice        % first check for 0% coh trials -- resids        %   should be nan        if any(L0)            resids_ = nans(size(L0,1), 2);            resids_(~L0, 2) = [rdo rro]                    else            resids_ = [rdo rro];        end    end    end