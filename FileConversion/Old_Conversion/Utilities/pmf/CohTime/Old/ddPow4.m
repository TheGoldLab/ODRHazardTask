function vals_ = ddPow4(fits, data)% function vals_ = ddPow4(fits, data)%% Computes TIME-based DDleak function.%   Assumes DD to a fixed TIME (given as col 2 of data).%   Thus, pct correct is fraction of gaussian above%       0 at TIME.%   Drift rate depends on coherence as a power law:%       u(coh) = A*coh^M%%   at values in "data":%       data(1)   ... coh (%)%       data(2)   ... time (s)%       data(3)   ... dot dir (-1/1)%%   given parameters in "fits":%       fits(1) ... A      (coh scale)%       fits(2) ... M      (coh exponent)%       fits(3) ... N      (time exponent)%       fits(4) ... lambda ("lapse")% return initial values (init, min, max)if nargin < 1        vals_ = [ ...        10    0.1   200;   ...        1.2   0.001   6;    ...        0.2   0.001   6;    ...        0     0     0.25];else        R0 = 10;    S1 = (R0 + fits(1).*data(:,1).^fits(2)).*data(:,2).^fits(3);    S2 = R0.*data(:,2).^fits(3);        mu = S1 - S2;    sd = sqrt(0.3.*(S1+S2));        % compute pct correct from the dvar    p = 1 - normcdf(0,mu,sd);        % Avoid NaN's in normcdf, which happens when s=0 (i.e., time=0)    p(isnan(p)) = 0.5;     % otherwise is NaN    TINY        = 0.0001;    p(p<TINY)   = TINY;    % lower bound    p(p>1-TINY) = 1-TINY;  % upper bound    % abbott's law    % for dealing with performance that does not asymptote at 1    % C = performance at chance    % D = asymptote as stim -> inf    % Abbott's law: p* = C + (1 - C - D)P    % where P is percent correct on [0 ... 1]    % But remember that the p we just computed is [C ... 1], C = 0.5;    % i.e., p = C + (1 - C)P    vals_ = 0.5 + (0.5 - fits(4)).*(2.*p-1);end