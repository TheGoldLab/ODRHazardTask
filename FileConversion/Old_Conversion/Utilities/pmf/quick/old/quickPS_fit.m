function [fits_,llik_,pred_,sems_] = quickPS_fit(data, lambda)% function [fits_,llik_,pred_,sems_] = quickPS_fit(data, lambda)%% Probability summation version of the quick fit% data is [cohs times correct] x trials%if nargin < 1 | isempty(data)  return;endglobal DATADATA = data;clear data;if nargin < 2 | isempty(lambda)     [fits,f,e,o,l,g,H] = fmincon('quickPS_err', ...        [22    1   0.1], [], [], [], [], ...        [0.001 0   0], ...        [10000 inf 0.5], [], optimset('LargeScale', 'off', ...        'Display', 'off', 'Diagnostics', 'off'));    lambda = fits(3);else    [fits,f,e,o,l,g,H] = fmincon('quickPS_err', ...        [22      1  ], [], [], [], [], ...        [0.001 0  ], ...        [10000 inf], [], optimset('LargeScale', 'off', ...        'Display', 'off', 'Diagnostics', 'off'), lambda);end% return the fitsif nargout > 0    fits_ = fits';end% return log likelihoodif nargout > 1    llik_ = -quickPS_err(fits_, lambda);end% return the predicted probability (of a correct response) for each observationif nargout > 2    pred_ = quick_val(DATA(:,1), fits_(1), fits_(2), lambda);end        % standard errors% The covariance matrix is the negative of the inverse of the % hessian of the natural logarithm of the probability of observing % the data set given the optimal parameters.% For now, use the numerically-estimated HESSIAN returned by fmincon% (which remember is computed from -log likelihood)if nargout > 3        cov_mat=-((-H)^(-1)); % -H because we used -logL in quick_err    sems_=sqrt(diag(cov_mat));    sems_ = [sems_ sems_];    end