function p_ = ddPow_val(data, params)% function p_ = ddPow_val(data, params)%% Computes TIME-based DDPow function.%   Assumes DD to a fixed TIME (given as col 2 of data).%   Thus, pct correct is fraction of gaussian above%       0 at TIME.%   Drift rate depends on coherence as a power law:%       u(coh) = a*coh^m%   Accumulation depends on time as a power law:%       T^n%   Bias is initial offset for L/R%%   at values in "data":%       data(1)   ... coh (%)%       data(2)   ... time (s)%       data(3)   ... dot dir (-1/1)%%   given parameters in "params":%       params(1) ... B      (bias)%       params(2) ... A      (coh scale)%       params(3) ... M      (coh exponent)%       params(4) ... N      (time exponent)%       params(5) ... lambda ("lapse")R0 = 10;FF = 0.3;% BIAS = ADDING FIXED COH:%S1 = (R0 + params(1).*data(:,3) + params(2).*data(:,1).^params(3)).* ...%    data(:,2).^params(4);% BIAS = ADDING FIXED OFFSETS1 = params(1).*data(:,3) + (R0 + params(2).*data(:,1).^params(3)).* ...    data(:,2).^params(4);S2 = R0.*data(:,2).^params(4);mu = S1 - S2;s  = sqrt(FF.*(S1 + S2));% compute pct correct from the dvarp = 1 - normcdf(0,mu,s);% Avoid NaN's in normcdf, which happens when s=0 (i.e., time=0)p(isnan(p)) = 0.5;     % otherwise is NaNTINY        = 0.0001;p(p<TINY)   = TINY;    % lower boundp(p>1-TINY) = 1-TINY;  % upper bound% abbott's law% for dealing with performance that does not asymptote at 1% C = performance at chance% D = asymptote as stim -> inf% Abbott's law: p* = C + (1 - C - D)P% where P is percent correct on [0 ... 1]% But remember that the p we just computed is [C ... 1], C = 0.5;% i.e., p = C + (1 - C)P% C = 0.5;p_ = 0.5+2.0.*(0.5-params(5)).*(p-0.5);