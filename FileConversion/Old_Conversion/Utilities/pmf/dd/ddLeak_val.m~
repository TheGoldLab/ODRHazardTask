function p_ = ddLeak_val(data, fits)% function p_ = ddLeak_val(data, fits)%% Computes TIME-based DDleak function.%   Assumes DD to a fixed TIME (given as col 2 of data).%   Thus, pct correct is fraction of gaussian above%       0 at TIME.%   Drift rate depends on coherence as a power law:%       u(coh) = A*coh^M%   Bias is fixed offset plus noise%       bias = normrnd(B, Bsd)%%   Accumulator leaks with "leakiness constant" L. Thus%   mean  u(t) = bias + u/L*(1-exp(-Lt))%   SD   sd(t) = sd/sqrt(L)*sqrt(1-exp(-2*L*t))%%   at values in "data":%       data(1)   ... coh (%)%       data(2)   ... time (s)%       data(3)   ... dot dir (-1/1)%%   given parameters in "fits":%       fits(1) ... A      (coh scale)%       fits(2) ... M      (coh exponent)%       fits(3) ... L      (accumulator leak)%       fits(4) ... B      (bias)%       fits(5) ... Bsd    (SD of bias)%       fits(6) ... FF     (var/mean)%       fits(7) ... lambda ("lapse")% see also quickT_fit and quickT_errR0 = 10;S1 = R0 + fits(1).*data(:,1).^fits(2);S2 = R0;bias = normrnd(data(:,3).*fits(4), fits(5));mu = bias + (S1-S2)./fits(3).*(1-exp(-fits(3).*data(:,2)));sd = sqrt(fits(6).*(S1+S2) + offset = R0 + data(:,3).*fits(5) + normrnd(0, fits(6), size(data, 1), 1);S1 = offset + fits(1).*data(:,1).^fits(2);S2 = R0;mu = (S1 - S2)./fits(3).*(1-exp(-fits(3).*data(:,2)));s  = sqrt((fits(4).*abs(S1+S2))./fits(3).*(1-exp(-2.*fits(3).*data(:,2))));% compute pct correct from the dvarp = 1 - normcdf(0,mu,s);% Avoid NaN's in normcdf, which happens when s=0 (i.e., time=0)p(isnan(p)) = 0.5;     % otherwise is NaNTINY        = 0.0001;p(p<TINY)   = TINY;    % lower boundp(p>1-TINY) = 1-TINY;  % upper bound% abbott's law% for dealing with performance that does not asymptote at 1% C = performance at chance% D = asymptote as stim -> inf% Abbott's law: p* = C + (1 - C - D)P% where P is percent correct on [0 ... 1]% But remember that the p we just computed is [C ... 1], C = 0.5;% i.e., p = C + (1 - C)P% separate for left/rightC = 0.5 + data(:,3).*(fits(5) + fits(6).*data(:,2));p_ = C + (1 - C - fits(4)).*(2.*p-1);