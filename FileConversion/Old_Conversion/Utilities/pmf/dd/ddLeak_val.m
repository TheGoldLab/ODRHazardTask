function p_ = ddLeak_val(data, fits)% function p_ = ddLeak_val(data, fits)%% Computes TIME-based DDleak function.%   Assumes DD to a fixed TIME (given as col 2 of data).%   Thus, pct correct is fraction of gaussian above%       0 at TIME.%   Drift rate depends on coherence as a power law:%       u(coh) = A*coh^M%   Bias is fixed offset plus noise%       bias = normrnd(B, Bsd)%%   Accumulator leaks with "leakiness constant" L. Thus%   mean  u(t) = bias_mean + u/L*(1-exp(-Lt))%   SD   sd(t) = sqrt(bias_var + FF *mean/L*(1-exp(-2*Lt))))%       where%           FF is fano factor, var/mean for S1 and S2%%   at values in "data":%       data(1)   ... coh (%)%       data(2)   ... time (s)%       data(3)   ... dot dir (-1/1)%%   given parameters in "fits":%       fits(1) ... A      (coh scale)%       fits(2) ... M      (coh exponent)%       fits(3) ... L      (accumulator leak)%       fits(4) ... B      (bias)%       fits(5) ... Bvar   (var of bias)%       fits(6) ... FF     (var/mean)%       fits(7) ... lambda ("lapse")% see also quickT_fit and quickT_errR0 = 10;S1 = R0 + fits(1).*data(:,1).^fits(2);S2 = R0;if fits(6) == 0    fits(6) = 0.0001;endmu = data(:,3).*fits(4) + (S1-S2)./fits(3).*(1-exp(-fits(3).*data(:,2)));sd = sqrt(fits(5) + fits(6).*(S1+S2)./fits(3).*(1-exp(-2.*fits(3).*data(:,2))));% compute pct correct from the dvarp = 1 - normcdf(0,mu,sd);% Avoid NaN's in normcdf, which happens when s=0 (i.e., time=0)p(isnan(p)) = 0.5;     % otherwise is NaNTINY        = 0.0001;p(p<TINY)   = TINY;    % lower boundp(p>1-TINY) = 1-TINY;  % upper bound% abbott's law% for dealing with performance that does not asymptote at 1% C = performance at chance% D = asymptote as stim -> inf% Abbott's law: p* = C + (1 - C - D)P% where P is percent correct on [0 ... 1]% But remember that the p we just computed is [C ... 1], C = 0.5;% i.e., p = C + (1 - C)Pp_ = 0.5 + (0.5 - fits(7)).*(2.*p-1);